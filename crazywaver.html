<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Crazy Waver</title>
<style>
  html,body{height:100%;margin:0;background:rgb(23,20,23);overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;background:rgb(23,20,23);image-rendering:pixelated}
  
  #back-button {
    position: fixed;
    top: 15px;
    left: 15px;
    padding: 10px 20px;
    background: rgba(138, 43, 226, 0.7);
    color: white;
    border: 2px solid white;
    border-radius: 25px;
    font-family: system-ui, -apple-system, sans-serif;
    font-size: 16px;
    cursor: pointer;
    z-index: 100;
    text-decoration: none;
    transition: all 0.3s ease;
  }
  
  #back-button:hover {
    background: rgba(138, 43, 226, 0.9);
    transform: scale(1.05);
  }
  
  #hud {
    position: fixed;
    top: 15px;
    right: 15px;
    color: white;
    font-family: system-ui, -apple-system, sans-serif;
    font-size: 16px;
    text-align: right;
    z-index: 100;
    background: rgba(0, 0, 0, 0.5);
    padding: 10px 15px;
    border-radius: 10px;
  }
  
  #hud div {
    margin: 5px 0;
  }
</style>
</head>
<body>
<a id="back-button" href="https://viyanajith.github.io/hard-games/mainscreen.html">← Back to Menu</a>
<div id="hud">
  <div id="score">Score: 0</div>
  <div id="highscore">Highscore: 0</div>
</div>
<canvas id="stage"></canvas>
<script>
(() => {
  const BG = 'rgb(23, 20, 23)';
  const PIPE_COLOR = '#8a2be2'; // purple

  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');

  // ===== DPI-aware full screen =====
  let W=0, H=0;
  function resizeCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    W = Math.floor(innerWidth);
    H = Math.floor(innerHeight);
    canvas.width  = Math.floor(W*dpr);
    canvas.height = Math.floor(H*dpr);
    canvas.style.width = W+'px';
    canvas.style.height= H+'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // sync rect height & clamp hole
    rect.h = H;
    if (rect.holeY > H - HOLE_H) rect.holeY = Math.max(0, H - HOLE_H);
    if (state==='play') rect.x = Math.min(rect.x, W - rect.w);
  }
  addEventListener('resize', resizeCanvas);

  // ===== Scratch-like player coords (center origin) =====
  const toX = x => x + W/2;
  const toY = y => H/2 - y;

  // ===== Player =====
  const player = { x:-180, y:0, size:20 };
  const trail = [];
  function spawnTrail(){
    trail.push({ x:player.x, y:player.y, base:player.size, frames:0, alpha:1, scale:0.90 });
  }

  // ===== Pipe (single) =====
  const RECT_W = 100;               // width (px)
  const HOLE_W = RECT_W;
  const HOLE_H = 75;                // gap height (px) — decimals allowed (e.g., 75.0)
  const SPEED_PER_TICK = 12;        // pipe speed (px left per 33ms tick)

  const rect = { x:0, w:RECT_W, h:0, holeY:0, scored:false };
  function rerollHole(){ rect.holeY = (H <= HOLE_H) ? 0 : (Math.random()*(H - HOLE_H))|0; }

  // ===== Old-style explosion (simple shards, gravity + spin) =====
  let shards = [];
  let reloadCountdownMs = null;
  let state = 'play'; // 'play' | 'exploding'

  function spawnPlayerExplosion(screenCX, screenCY){
    state = 'exploding';
    const chunk = 6;
    const left = screenCX - player.size/2;
    const top  = screenCY - player.size/2;

    for (let yy=0; yy<player.size; yy+=chunk){
      for (let xx=0; xx<player.size; xx+=chunk){
        const w = Math.min(chunk, player.size - xx);
        const h = Math.min(chunk, player.size - yy);
        const cx = left + xx + w/2;
        const cy = top  + yy + h/2;

        const dx = cx - screenCX, dy = cy - screenCY;
        const dist = Math.hypot(dx,dy) || 1;
        const nx = dx / dist, ny = dy / dist;
        const base = 8 + Math.random()*3;
        const swirl = (Math.random()*2 - 1) * 1.8;
        const vx = nx*base + (-ny)*swirl;
        const vy = ny*base + ( nx)*swirl - 4;

        shards.push({
          cx, cy, w, h,
          vx, vy,
          angle: (Math.random()*Math.PI*2),
          omega: (Math.random()*2 - 1) * 0.25
        });
      }
    }
  }

  function updateShards(){
    if (shards.length === 0){
      if (reloadCountdownMs === null) reloadCountdownMs = 1000; // 1 seconds for reload
      return;
    }
    const GRAV = 1.0;
    const DRAG = 0.992;

    for (let i = shards.length - 1; i >= 0; i--){
      const s = shards[i];
      s.vy += GRAV;
      s.vx *= DRAG; s.vy *= DRAG; s.omega *= 0.997;
      s.cx += s.vx; s.cy += s.vy; s.angle += s.omega;

      // delete when bottom hits screen bottom (rotated-rect Y extent)
      const c = Math.cos(s.angle), sn = Math.sin(s.angle);
      const yExtent = Math.abs(c)*(s.h/2) + Math.abs(sn)*(s.w/2);
      const bottom = s.cy + yExtent;
      if (bottom >= H) shards.splice(i,1);
    }
  }

  function drawShards(){
    ctx.fillStyle = '#ffffff';
    for (const s of shards){
      ctx.save();
      ctx.translate(s.cx, s.cy);
      ctx.rotate(s.angle);
      ctx.fillRect(-s.w/2, -s.h/2, s.w, s.h);
      ctx.restore();
    }
  }

  // ===== Score & Highscore (with localStorage) =====
  let score = 0;
  let highscore = 0;
  const HS_KEY = 'crazyWaverHighScore';

  function loadHighscore(){
    try {
      const v = localStorage.getItem(HS_KEY);
      highscore = v ? Math.max(0, parseInt(v, 10) || 0) : 0;
    } catch { highscore = 0; }
  }
  function maybeUpdateHighscore(){
    if (score > highscore){
      highscore = score;
      try { localStorage.setItem(HS_KEY, String(highscore)); } catch {}
    }
  }

  // ===== Input =====
  const keys = new Set();
  
  // Keyboard controls
  addEventListener('keydown', e => {
    if (e.code==='Space'){ e.preventDefault(); keys.add('Space'); }
    if (e.key?.toLowerCase()==='c'){ trail.length = 0; } // clear trail
  }, {passive:false});
  
  addEventListener('keyup', e => { 
    if (e.code==='Space'){ e.preventDefault(); keys.delete('Space'); }
  }, {passive:false});
  
  // Mouse/touch controls
  const handlePointerDown = (e) => {
    e.preventDefault();
    keys.add('Space');
  };
  
  const handlePointerUp = (e) => {
    e.preventDefault();
    keys.delete('Space');
  };
  
  // Add event listeners for mouse and touch
  document.addEventListener('mousedown', handlePointerDown);
  document.addEventListener('mouseup', handlePointerUp);
  document.addEventListener('touchstart', handlePointerDown, {passive: false});
  document.addEventListener('touchend', handlePointerUp, {passive: false});
  
  // Prevent default touch behavior to avoid scrolling
  document.addEventListener('touchmove', (e) => {
    if (keys.has('Space')) {
      e.preventDefault();
    }
  }, { passive: false });

  // ===== Utils =====
  function aabb(ax,ay,aw,ah, bx,by,bw,bh){
    return ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by;
  }

  // ===== Fixed 33ms tick =====
  const STEP_MS = 33;
  let last = performance.now(), acc = 0;

  function logicTick(){
    if (state === 'play'){
      // Player: +10y when Space, else -10y
      player.y += keys.has('Space') ? 10 : -10;

      // Trail (8 ticks life)
      spawnTrail();
      for (let i=trail.length-1; i>=0; i--){
        const t = trail[i];
        if (t.frames>0){ t.alpha=Math.max(0,t.alpha-0.25); t.scale=Math.max(0,t.scale-0.12); }
        t.frames++; if (t.frames>8) trail.splice(i,1);
      }

      // Pipe movement
      rect.x -= SPEED_PER_TICK;
      // Score when the pipe fully passes left of the player X
      const playerCenterX = Math.round(toX(player.x));
      if (!rect.scored && (rect.x + rect.w) < playerCenterX){
        rect.scored = true;
        score += 1;
        maybeUpdateHighscore();
      }

      if (rect.x + rect.w < 0){
        rect.x = W - rect.w;
        rect.h = H;
        rerollHole();
        rect.scored = false; // new pipe, ready to score again
      }

      // Collision (exclude the hole)
      const ps = player.size;
      const px = Math.round(toX(player.x) - ps/2);
      const py = Math.round(toY(player.y) - ps/2);

      const topBlock = { x:rect.x, y:0, w:rect.w, h:rect.holeY };
      const bottomStart = rect.holeY + HOLE_H;
      const bottomBlock = { x:rect.x, y:bottomStart, w:rect.w, h:Math.max(0, H - bottomStart) };

      let hit = false;
      if ((topBlock.h>0 && aabb(px,py,ps,ps, topBlock.x,topBlock.y,topBlock.w,topBlock.h)) ||
          (bottomBlock.h>0 && aabb(px,py,ps,ps, bottomBlock.x,bottomBlock.y,bottomBlock.w,bottomBlock.h))) {
        hit = true;
      }

      // Edge collision (top/bottom of screen)
      const pyTop = py;
      const pyBottom = py + ps;
      if (pyTop <= 0 || pyBottom >= H) {
        hit = true;
      }

      if (hit){
        const pcx = px + ps/2, pcy = py + ps/2;
        spawnPlayerExplosion(pcx, pcy);
      }

    } else if (state === 'exploding'){
      // Let existing trail fade; no new spawns
      for (let i=trail.length-1; i>=0; i--){
        const t = trail[i];
        if (t.frames>0){ t.alpha=Math.max(0,t.alpha-0.25); t.scale=Math.max(0,t.scale-0.12); }
        t.frames++; if (t.frames>8) trail.splice(i,1);
      }

      updateShards();
      if (reloadCountdownMs !== null){
        reloadCountdownMs -= STEP_MS;
        if (reloadCountdownMs <= 0) location.reload();
      }
    }
  }

  function render(){
    // BG
    ctx.fillStyle = BG; ctx.fillRect(0,0,W,H);

    // Trail (behind)
    for (const t of trail){
      const size = t.base * t.scale;
      ctx.globalAlpha = t.alpha;
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(
        Math.round(toX(t.x) - size/2),
        Math.round(toY(t.y) - size/2),
        Math.round(size),
        Math.round(size)
      );
    }
    ctx.globalAlpha = 1;

    // Pipe
    ctx.fillStyle = PIPE_COLOR;
    ctx.fillRect(rect.x, 0, rect.w, rect.h);
    // Hole
    ctx.fillStyle = BG;
    ctx.fillRect(rect.x, rect.holeY, HOLE_W, HOLE_H);

    // Player or shards
    if (state === 'play'){
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(
        Math.round(toX(player.x) - player.size/2),
        Math.round(toY(player.y) - player.size/2),
        player.size, player.size
      );
    } else {
      drawShards();
    }

    // Update HUD elements
    document.getElementById('score').textContent = `Score: ${score}`;
    document.getElementById('highscore').textContent = `Highscore: ${highscore}`;
  }

  function frame(now){
    acc += now - last; last = now;
    while (acc >= STEP_MS){ logicTick(); acc -= STEP_MS; }
    render();
    requestAnimationFrame(frame);
  }

  function start(){
    resizeCanvas();
    // Init
    loadHighscore();
    score = 0;
    player.x = -180; player.y = 0; trail.length = 0;
    rect.x = W - rect.w; rect.h = H; rerollHole(); rect.scored = false;
    shards = []; reloadCountdownMs = null; state = 'play';
    last = performance.now(); acc = 0;
    requestAnimationFrame(frame);
  }

  start();
})();
</script>
</body>
</html>